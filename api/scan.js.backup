const express = require('express');
const isDev = process.env.NODE_ENV !== 'production';
const puppeteer = isDev ? require('puppeteer') : require('puppeteer-core');
const chromium = require('@sparticuz/chromium');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 4000;

app.use(cors({
    origin: '*', // Allow all origins for now to fix CORS issues
    methods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type']
}));
app.use(express.json());

app.post('/api/scan', async (req, res) => {
    const { url, scanMultiplePages = false } = req.body;

    if (!url) {
        return res.status(400).json({ error: 'URL is required' });
    }

    let browser;
    try {
        console.log(`Starting scan for: ${url} (Multi-page: ${scanMultiplePages})`);

        browser = await puppeteer.launch(
            isDev
                ? {
                    headless: 'new',
                    args: ['--no-sandbox', '--disable-setuid-sandbox']
                }
                : {
                    args: chromium.args,
                    defaultViewport: chromium.defaultViewport,
                    executablePath: await chromium.executablePath(),
                    headless: chromium.headless,
                }
        );

        // Helper function to extract navigation links
        const extractNavLinks = async (pageUrl) => {
            const page = await browser.newPage();
            await page.setViewport({ width: 1920, height: 1080 });

            try {
                await page.goto(pageUrl, { waitUntil: 'networkidle0', timeout: 60000 });

                const links = await page.evaluate((baseUrl) => {
                    const navLinks = new Set();
                    const baseUrlObj = new URL(baseUrl);

                    // Look for navigation links in common nav elements
                    const navSelectors = [
                        'nav a',
                        'header a',
                        '.nav a',
                        '.navigation a',
                        '.menu a',
                        '[role="navigation"] a'
                    ];

                    navSelectors.forEach(selector => {
                        document.querySelectorAll(selector).forEach(link => {
                            try {
                                const href = link.href;
                                const linkUrl = new URL(href);

                                // Only include links from the same domain
                                if (linkUrl.hostname === baseUrlObj.hostname &&
                                    !href.includes('#') &&
                                    !href.includes('mailto:') &&
                                    !href.includes('tel:')) {
                                    navLinks.add(href);
                                }
                            } catch (e) {
                                // Invalid URL, skip
                            }
                        });
                    });

                    return Array.from(navLinks);
                }, pageUrl);

                await page.close();
                return links;
            } catch (error) {
                console.error('Error extracting nav links:', error);
                await page.close();
                return [];
            }
        };

        // Determine which URLs to scan
        let urlsToScan = [url];

        if (scanMultiplePages) {
            console.log('Extracting navigation links...');
            const navLinks = await extractNavLinks(url);
            // Add up to 6 additional pages (total 7 including homepage)
            urlsToScan = [url, ...navLinks.slice(0, 6)];
            console.log(`Found ${navLinks.length} nav links, scanning ${urlsToScan.length} pages total`);
        }

        const scrapeDesignSystem = async (pageUrl, viewport) => {
            const page = await browser.newPage();
            await page.setViewport(viewport);

            try {
                await page.goto(pageUrl, { waitUntil: 'networkidle0', timeout: 60000 });

                const data = await page.evaluate(async () => {
                    // --- Helpers ---
                    const rgbToHex = (rgb) => {
                        if (!rgb || rgb === 'transparent' || rgb === 'rgba(0, 0, 0, 0)') return null;
                        if (rgb.startsWith('#')) return rgb;

                        const rgbValues = rgb.match(/\d+/g);
                        if (!rgbValues) return null;

                        const r = parseInt(rgbValues[0]);
                        const g = parseInt(rgbValues[1]);
                        const b = parseInt(rgbValues[2]);
                        // Ignore alpha for hex conversion for now, or handle it
                        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
                    };

                    const allElements = document.querySelectorAll('*');

                    // Data structures
                    const typography = new Map();
                    const colors = {
                        palette: new Set(), // All unique colors
                        backgrounds: new Set(),
                        text: new Set(),
                        borders: new Set(),
                        gradients: new Set(),
                        counts: {}
                    };
                    const spacing = {
                        gaps: new Set(),
                        containerWidths: new Set(),
                        paddings: new Set(),
                        margins: new Set()
                    };
                    const borders = {
                        radius: new Set(),
                        widths: new Set(),
                        styles: new Set(),
                        boxShadows: new Set()
                    };
                    const components = {
                        buttons: [],
                        inputs: [],
                        icons: []
                    };
                    const brand = {
                        logo: null,
                        socialLinks: [],
                        meta: {}
                    };

                    // Helper to count color usage
                    const trackColor = (color, type) => {
                        const hex = rgbToHex(color);
                        if (!hex) return;

                        colors.palette.add(hex);
                        if (type === 'bg') colors.backgrounds.add(hex);
                        if (type === 'text') colors.text.add(hex);
                        if (type === 'border') colors.borders.add(hex);

                        colors.counts[hex] = (colors.counts[hex] || 0) + 1;
                    };

                    // --- Brand Extraction ---
                    // Meta tags
                    const ogImage = document.querySelector('meta[property="og:image"]');
                    const twitterImage = document.querySelector('meta[name="twitter:image"]');
                    const icon = document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');

                    brand.meta.ogImage = ogImage ? ogImage.content : null;
                    brand.meta.twitterImage = twitterImage ? twitterImage.content : null;
                    brand.meta.favicon = icon ? icon.href : null;

                    // Logo - Try harder to find it
                    const logoSelectors = [
                        'header img', '.logo img', '#logo img', 'a[href="/"] img',
                        'img[src*="logo"]', 'img[alt*="logo"]', '.navbar-brand img'
                    ];

                    for (const selector of logoSelectors) {
                        const el = document.querySelector(selector);
                        if (el && el.src) {
                            brand.logo = {
                                src: el.src,
                                width: el.naturalWidth || el.width,
                                height: el.naturalHeight || el.height
                            };
                            break;
                        }
                    }
                    // Fallback to favicon if no logo found
                    if (!brand.logo && brand.meta.favicon) {
                        brand.logo = { src: brand.meta.favicon, isFavicon: true };
                    }


                    // Social Links
                    const socialDomains = ['facebook.com', 'twitter.com', 'instagram.com', 'linkedin.com', 'youtube.com', 'github.com', 'tiktok.com', 'x.com'];
                    document.querySelectorAll('a').forEach(a => {
                        if (socialDomains.some(d => a.href.includes(d))) {
                            brand.socialLinks.push(a.href);
                        }
                    });

                    // --- Element Iteration ---
                    allElements.forEach(el => {
                        if (['SCRIPT', 'STYLE', 'NOSCRIPT', 'SVG', 'PATH', 'HEAD', 'META', 'LINK'].includes(el.tagName)) return;

                        // Visibility check
                        const rect = el.getBoundingClientRect();
                        if (rect.width === 0 || rect.height === 0) return;

                        const computed = window.getComputedStyle(el);

                        // --- Typography ---
                        if (el.innerText && el.innerText.trim().length > 0) {
                            const fontSizePx = parseFloat(computed.fontSize);
                            const lineHeightPx = parseFloat(computed.lineHeight) || fontSizePx * 1.2;
                            const key = `${computed.fontFamily}-${computed.fontSize}-${computed.fontWeight}-${computed.lineHeight}-${computed.color}`;

                            if (!typography.has(key)) {
                                typography.set(key, {
                                    fontFamily: computed.fontFamily,
                                    fontSize: computed.fontSize,
                                    fontSizePx: fontSizePx,
                                    fontWeight: computed.fontWeight,
                                    lineHeight: computed.lineHeight,
                                    lineHeightPx: lineHeightPx,
                                    color: rgbToHex(computed.color) || computed.color,
                                    tagName: el.tagName,
                                    isInjected: false
                                });
                            }
                        }

                        // --- Colors ---
                        trackColor(computed.color, 'text');
                        trackColor(computed.backgroundColor, 'bg');
                        trackColor(computed.borderColor, 'border');

                        if (computed.backgroundImage && computed.backgroundImage.includes('gradient')) {
                            colors.gradients.add(computed.backgroundImage);
                        }

                        // --- Spacing ---
                        if (computed.gap && computed.gap !== 'normal') spacing.gaps.add(computed.gap);

                        // Container Widths logic
                        if (computed.maxWidth && computed.maxWidth !== 'none') {
                            const widthVal = parseFloat(computed.maxWidth);
                            if (!isNaN(widthVal)) {
                                let category = 'Unknown';
                                if (widthVal < 600) category = 'Mobile';
                                else if (widthVal < 1024) category = 'Tablet';
                                else if (widthVal < 1440) category = 'Laptop';
                                else category = 'Desktop';

                                spacing.containerWidths.add(JSON.stringify({ value: computed.maxWidth, category, px: widthVal }));
                            }
                        }

                        // --- Borders ---
                        if (computed.borderRadius && computed.borderRadius !== '0px') borders.radius.add(computed.borderRadius);
                        if (computed.borderWidth && computed.borderWidth !== '0px') borders.widths.add(computed.borderWidth);
                        if (computed.boxShadow && computed.boxShadow !== 'none') borders.boxShadows.add(computed.boxShadow);

                        // --- Components ---
                        // Buttons - Capture comprehensive styling
                        if (el.tagName === 'BUTTON' || (el.tagName === 'A' && (el.className.includes('btn') || el.className.includes('button')))) {
                            const bgColor = rgbToHex(computed.backgroundColor);
                            if (bgColor && bgColor !== '#FFFFFF' && bgColor !== '#000000') {
                                components.buttons.push({
                                    text: el.innerText.trim().substring(0, 30) || 'Button',
                                    bg: bgColor,
                                    color: rgbToHex(computed.color),
                                    radius: computed.borderRadius,
                                    padding: computed.padding,
                                    border: computed.border,
                                    borderColor: rgbToHex(computed.borderColor),
                                    fontSize: computed.fontSize,
                                    fontWeight: computed.fontWeight,
                                    fontFamily: computed.fontFamily,
                                    textTransform: computed.textTransform,
                                    letterSpacing: computed.letterSpacing,
                                    boxShadow: computed.boxShadow,
                                    width: computed.width,
                                    height: computed.height,
                                    display: computed.display,
                                    alignItems: computed.alignItems,
                                    justifyContent: computed.justifyContent
                                });
                            }
                        }
                    });

                    // --- Form Components (Comprehensive) ---
                    const formComponents = {
                        textInputs: [],
                        textareas: [],
                        selects: [],
                        checkboxes: [],
                        radios: [],
                        toggles: []
                    };

                    // Text Inputs (text, email, password, number, etc.)
                    const textInputs = document.querySelectorAll('input[type="text"], input[type="email"], input[type="password"], input[type="number"], input[type="search"], input[type="tel"], input[type="url"], input:not([type])');
                    textInputs.forEach(input => {
                        const comp = window.getComputedStyle(input);
                        formComponents.textInputs.push({
                            type: input.type || 'text',
                            placeholder: input.placeholder || '',
                            base: {
                                bg: rgbToHex(comp.backgroundColor),
                                border: comp.border,
                                borderColor: rgbToHex(comp.borderColor),
                                color: rgbToHex(comp.color),
                                radius: comp.borderRadius,
                                padding: comp.padding,
                                shadow: comp.boxShadow,
                                fontSize: comp.fontSize,
                                fontWeight: comp.fontWeight,
                                fontFamily: comp.fontFamily,
                                width: comp.width,
                                height: comp.height
                            }
                        });
                    });

                    // Textareas
                    const textareas = document.querySelectorAll('textarea');
                    textareas.forEach(textarea => {
                        const comp = window.getComputedStyle(textarea);
                        formComponents.textareas.push({
                            placeholder: textarea.placeholder || '',
                            rows: textarea.rows || 3,
                            base: {
                                bg: rgbToHex(comp.backgroundColor),
                                border: comp.border,
                                borderColor: rgbToHex(comp.borderColor),
                                color: rgbToHex(comp.color),
                                radius: comp.borderRadius,
                                padding: comp.padding,
                                shadow: comp.boxShadow,
                                fontSize: comp.fontSize,
                                fontWeight: comp.fontWeight,
                                fontFamily: comp.fontFamily,
                                width: comp.width,
                                minHeight: comp.minHeight,
                                resize: comp.resize
                            }
                        });
                    });

                    // Select (Dropdowns)
                    const selects = document.querySelectorAll('select');
                    selects.forEach(select => {
                        const comp = window.getComputedStyle(select);
                        const options = Array.from(select.options).slice(0, 3).map(opt => opt.text);
                        formComponents.selects.push({
                            options: options,
                            base: {
                                bg: rgbToHex(comp.backgroundColor),
                                border: comp.border,
                                borderColor: rgbToHex(comp.borderColor),
                                color: rgbToHex(comp.color),
                                radius: comp.borderRadius,
                                padding: comp.padding,
                                shadow: comp.boxShadow,
                                fontSize: comp.fontSize,
                                fontWeight: comp.fontWeight,
                                fontFamily: comp.fontFamily,
                                width: comp.width,
                                height: comp.height,
                                appearance: comp.appearance
                            }
                        });
                    });

                    // Checkboxes
                    const checkboxes = document.querySelectorAll('input[type="checkbox"]');
                    checkboxes.forEach(checkbox => {
                        const comp = window.getComputedStyle(checkbox);
                        const label = checkbox.labels && checkbox.labels[0] ? checkbox.labels[0].textContent.trim() : '';
                        formComponents.checkboxes.push({
                            label: label,
                            checked: checkbox.checked,
                            base: {
                                bg: rgbToHex(comp.backgroundColor),
                                border: comp.border,
                                borderColor: rgbToHex(comp.borderColor),
                                color: rgbToHex(comp.color),
                                radius: comp.borderRadius,
                                width: comp.width,
                                height: comp.height,
                                accentColor: comp.accentColor || null
                            }
                        });
                    });

                    // Radio Buttons
                    const radios = document.querySelectorAll('input[type="radio"]');
                    radios.forEach(radio => {
                        const comp = window.getComputedStyle(radio);
                        const label = radio.labels && radio.labels[0] ? radio.labels[0].textContent.trim() : '';
                        formComponents.radios.push({
                            label: label,
                            checked: radio.checked,
                            base: {
                                bg: rgbToHex(comp.backgroundColor),
                                border: comp.border,
                                borderColor: rgbToHex(comp.borderColor),
                                color: rgbToHex(comp.color),
                                radius: comp.borderRadius,
                                width: comp.width,
                                height: comp.height,
                                accentColor: comp.accentColor || null
                            }
                        });
                    });

                    // Toggles (often implemented as checkboxes with custom styling)
                    // Look for checkboxes with switch/toggle classes or custom styling
                    const toggles = document.querySelectorAll('input[type="checkbox"].switch, input[type="checkbox"].toggle, .switch input[type="checkbox"], .toggle input[type="checkbox"]');
                    toggles.forEach(toggle => {
                        const comp = window.getComputedStyle(toggle);
                        const parent = toggle.closest('.switch, .toggle') || toggle.parentElement;
                        const parentComp = parent ? window.getComputedStyle(parent) : comp;
                        formComponents.toggles.push({
                            checked: toggle.checked,
                            base: {
                                bg: rgbToHex(parentComp.backgroundColor),
                                border: parentComp.border,
                                borderColor: rgbToHex(parentComp.borderColor),
                                radius: parentComp.borderRadius,
                                width: parentComp.width,
                                height: parentComp.height
                            }
                        });
                    });

                    // Deduplicate each type
                    const deduplicateArray = (arr, limit) => {
                        const unique = [];
                        const seen = new Set();
                        for (const item of arr) {
                            const str = JSON.stringify(item.base);
                            if (!seen.has(str)) {
                                seen.add(str);
                                unique.push(item);
                            }
                        }
                        return unique.slice(0, limit);
                    };

                    components.inputs = {
                        textInputs: deduplicateArray(formComponents.textInputs, 4),
                        textareas: deduplicateArray(formComponents.textareas, 2),
                        selects: deduplicateArray(formComponents.selects, 3),
                        checkboxes: deduplicateArray(formComponents.checkboxes, 3),
                        radios: deduplicateArray(formComponents.radios, 3),
                        toggles: deduplicateArray(formComponents.toggles, 2)
                    };

                    // Try to capture focus states for text inputs
                    const textInputEls = document.querySelectorAll('input[type="text"], input[type="email"], input[type="password"]');
                    for (let i = 0; i < Math.min(textInputEls.length, 2); i++) {
                        const el = textInputEls[i];
                        el.focus();
                        const focusComp = window.getComputedStyle(el);
                        const baseComp = components.inputs.textInputs.find(inp => inp.type === el.type);
                        if (baseComp) {
                            baseComp.focus = {
                                borderColor: rgbToHex(focusComp.borderColor),
                                shadow: focusComp.boxShadow,
                                bg: rgbToHex(focusComp.backgroundColor),
                                outline: focusComp.outline
                            };
                        }
                        el.blur();
                    }

                    // Deduplicate buttons
                    const uniqueButtons = [];
                    const buttonStrings = new Set();
                    for (const btn of components.buttons) {
                        const str = JSON.stringify({ bg: btn.bg, color: btn.color, text: btn.text });
                        if (!buttonStrings.has(str)) {
                            buttonStrings.add(str);
                            uniqueButtons.push(btn);
                        }
                    }
                    components.buttons = uniqueButtons.slice(0, 12);

                    // Sort colors by frequency
                    const sortedColors = Object.entries(colors.counts)
                        .sort(([, a], [, b]) => b - a)
                        .map(([color]) => color)
                        .slice(0, 10); // Top 10 colors

                    return {
                        typography: Array.from(typography.values()),
                        colors: {
                            palette: Array.from(colors.palette),
                            backgrounds: Array.from(colors.backgrounds),
                            text: Array.from(colors.text),
                            borders: Array.from(colors.borders),
                            gradients: Array.from(colors.gradients),
                            dominant: sortedColors
                        },
                        spacing: {
                            gaps: Array.from(spacing.gaps),
                            containerWidths: Array.from(spacing.containerWidths).map(s => JSON.parse(s))
                        },
                        borders: {
                            radius: Array.from(borders.radius),
                            widths: Array.from(borders.widths),
                            boxShadows: Array.from(borders.boxShadows)
                        },
                        components,
                        brand: {
                            ...brand,
                            socialLinks: [...new Set(brand.socialLinks)]
                        }
                    };
                });

                await page.close();
                return data;
            };

            // Scrape Desktop
            const desktopData = await scrapeDesignSystem({ width: 1920, height: 1080 });

            // Scrape Mobile (mainly for typography differences, but we can merge others if needed)
            const mobileData = await scrapeDesignSystem({ width: 375, height: 812 });

            // Helper to generate typography names
            const generateNames = (styles, prefix = '') => {
                return styles.sort((a, b) => b.fontSizePx - a.fontSizePx).map((style, index) => {
                    let name = `Text_${index + 1}`;
                    if (index === 0) name = `${prefix}Display`;
                    else if (index === 1) name = `${prefix}H1`;
                    else if (index === 2) name = `${prefix}H2`;
                    else if (index === 3) name = `${prefix}H3`;
                    else if (index === 4) name = `${prefix}H4`;
                    else if (index === 5) name = `${prefix}H5`;
                    else if (index === 6) name = `${prefix}H6`;
                    else name = `${prefix}Text_${index - 6}`;

                    return { ...style, name };
                });
            };

            // Extract unique font families
            const allStyles = [...desktopData.typography, ...mobileData.typography];
            const fontFamiliesSet = new Set();
            allStyles.forEach(style => {
                const cleanFamily = style.fontFamily.replace(/['"]/g, '').split(',')[0].trim();
                fontFamiliesSet.add(cleanFamily);
            });

            res.json({
                typography: {
                    desktop: generateNames(desktopData.typography),
                    mobile: generateNames(mobileData.typography, 'M_'),
                    fontFamilies: Array.from(fontFamiliesSet)
                },
                colors: desktopData.colors,
                spacing: desktopData.spacing,
                borders: desktopData.borders,
                components: desktopData.components,
                brand: desktopData.brand
            });

        } catch (error) {
            console.error('Scraping error:', error);
            res.status(500).json({ error: 'Failed to scan the website', details: error.message });
        } finally {
            if (browser) {
                await browser.close();
            }
        }
    });

// For Vercel serverless
if (isDev) {
    app.listen(PORT, () => {
        console.log(`Server running on http://localhost:${PORT}`);
    });
}

module.exports = app;
